---
title: Coatimunde Todo Document
updated: 1970-01-01
published: true
permalink: /todo
---

# Top items are most important

1. Figure out how to use any computer to collect images from the binocular drone to sastify the requirements to make a training set for [this software package](http://openaccess.thecvf.com/content_cvpr_2018/papers/Wang_Learning_Depth_From_CVPR_2018_paper.pdf). It appears they are using video streams and creating still frames using pixel shift values, they say their citation 31 is how they ‘prepared’ the datasets. If it is video then figure out how to capture bino video on that poor drone and just wander all over the lab for like an hour. They had like 150gb of pictures all at like 128 × 416 pixels (much lower def than you’d ever be able to capture) so the more the better. 
2. figure out how to apply a transform to quats with different magnitudes. This is the difficult part of updating our map, currently all points tend toward zero due to the manner in which multiplication between primary and secondary quaternorions are being used. All secondarys are small
3. Benchmark both the potential field and the odometry updating methods to see which requires more computational horzepouer, make this one take over shortening the number of remembered points list. Slicing in half whenever a timing can not be met would be the easiest way to do this. If the status-updater is the bottleneck, make it the other thing by clumping together multiple updates into a single vector that swells in size and is serviced whenever the process is able to. Maybe a smart idea would be putting the sending service on a timer loop and having it only send updates at 10hz, but I have no idea how syncing up these processes would work, and obviously if it could happen faster that would be ideal.
4. go root through the ‘publisher-subscriber’ headers of all of the code. I believe that this is the final configuration of passing m essages around that we will end up using (for better or for worse) so come up with the diagram that shows these things flowing around, who publishes to what, whatever.
5. figure out how to build some sort of diagnostic GUI for the mapping software, my idea currently would be to represent it as the robot as a dot in the middle of the screen, then just a unit circle going around it and then lines drawn on based only on the ‘Z’ component of the quaterneneoin. I have, very late today, learned that this quaterneonen is not what I thought it was though, so you should probably convert it to ‘eigen rotations’ first, then just look at the z component, then plot that on a unit circle with the number of the marker on the outside edge. Then if you want to get really fancy you could draw the number on the end of the stick too
6. Come up with some way to parse an angle out of a spotted aruco marker, this will require some math up front to figure out, based on how far away it is, how many pixels left or right represent an angle (it will change if it is closer), and then doing some actual measurements, both with the robot’s camera and then again (or at least be prepared to repeat it) with the flying robot’s camera
